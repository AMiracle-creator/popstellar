import { Unsubscribe } from 'redux';

import { publish, subscribeToChannel, unsubscribeFromChannel } from 'core/network';
import { getMessagesState } from 'core/network/ingestion';
import { ExtendedMessage } from 'core/network/ingestion/ExtendedMessage';
import { ActionType, ObjectType } from 'core/network/jsonrpc/messages';
import {
  channelFromIds,
  EventTags,
  getElectionKeyChannel,
  Hash,
  PublicKey,
  Timestamp,
} from 'core/objects';
import { getStore } from 'core/redux';

import { Election, ElectionVersion, Question, SelectedBallots } from '../objects';
import { makeElectionKeyStoreWatcher } from '../reducer/ElectionKeyWatcher';
import { CastVote, EndElection, SetupElection } from './messages';
import { OpenElection } from './messages/OpenElection';
import { RequestElectionKey } from './messages/RequestElectionKey';

/**
 * Contains all functions to send election related messages.
 */

/**
 * Requests an election key from the backend
 * @param laoId The id of the lao in which the new election will be created
 * @param electionId The id of the new election that will be created
 * @param laoOrganizerBackendPublicKey The public key of the lao organizer's backend
 * @returns The public key generated by the backend
 */
export const requestElectionKey = async (
  laoId: Hash,
  electionId: Hash,
  laoOrganizerBackendPublicKey: PublicKey,
): Promise<PublicKey> => {
  /* the channel where *all* election keys are requested and sent */
  const electionKeyChannel = getElectionKeyChannel(laoId);

  await subscribeToChannel(
    electionKeyChannel,
    /* follow the default network manager rule */
    undefined,
    /* it is *not* necessary to send a catchup on this channel, this reduceds overhead */
    false,
  );

  // after subscribing to the channel, prepare the election#request_key message
  const message = new RequestElectionKey({
    election: electionId,
  });

  // set up a listener so that we are notified as soon as we receive the corresponding election#key message
  let unsubscribeFromStore: Unsubscribe | null = null;

  const store = getStore();

  const key = await new Promise<{ electionKey: PublicKey; messageId: Hash }>((resolve, reject) => {
    // the watcher will resolve the promise as soon as an election#key message is observed
    const watcher = makeElectionKeyStoreWatcher(electionId.valueOf(), store, resolve);
    // set the variable that allows us to unsubscribe from the redux store after the
    // election#key message is found
    unsubscribeFromStore = store.subscribe(watcher);

    // now that the listener is set up, we can public the election#request_key message
    publish(electionKeyChannel, message).catch(reject);
  });

  // the variable is assigned in the Promise we are waiting on.
  // we cannot get here without the promise being fulfulled and thus the
  // value is always set
  (unsubscribeFromStore as unknown as Unsubscribe)();

  // we can now unsubscribe from the election key channel again
  await unsubscribeFromChannel(electionKeyChannel);

  // verify whether the election key was sent by the organizer
  // for this we retrieve the associated message from the store
  const msgState = getMessagesState(store.getState());
  const electionKeyMessage = ExtendedMessage.fromState(msgState.byId[key.messageId.valueOf()]);

  // sanity check
  if (
    electionKeyMessage.messageData.object !== ObjectType.ELECTION ||
    electionKeyMessage.messageData.action !== ActionType.KEY
  ) {
    throw new Error(
      'This should not happen! Only election#key messages are supposed to add entries to the election key store',
    );
  }

  // check if the sender of the message is the lao organizer's backend
  if (electionKeyMessage.sender !== laoOrganizerBackendPublicKey) {
    throw new Error(
      "The received election#key message was sent by somebody other than the lao's organizer!",
    );
  }

  // and return the obtained key
  return key.electionKey;
};

/**
 * Sends a query asking for the creation of an election.
 *
 * @param laoId - The id of the lao where this election should be created in
 * @param name - The name of the election
 * @param version - The version of the election
 * @param start - The start time of the election
 * @param end - The end time of the election
 * @param questions - The questions contained in the election
 * @param time - The creation time of the election
 * @param laoOrganizerBackendPublicKey - The public key of the lao organizer's backend
 */
export async function requestCreateElection(
  laoId: Hash,
  name: string,
  version: ElectionVersion,
  start: Timestamp,
  end: Timestamp,
  questions: Question[],
  time: Timestamp,
  laoOrganizerBackendPublicKey: PublicKey,
): Promise<void> {
  // first compute the election id
  const electionId = Hash.fromStringArray(
    EventTags.ELECTION,
    laoId.valueOf(),
    time.toString(),
    name,
  );

  // in case of a secret ballot election, we need to first request an election key
  let electionKey: PublicKey | undefined;
  if (version === ElectionVersion.SECRET_BALLOT) {
    electionKey = await requestElectionKey(laoId, electionId, laoOrganizerBackendPublicKey);
  }

  const message = new SetupElection({
    version: version,
    id: electionId,
    lao: laoId,
    name: name,
    key: electionKey,
    created_at: time,
    start_time: Timestamp.max(time, start),
    end_time: end,
    questions: questions,
  });

  // publish on the general LAO channel
  return publish(channelFromIds(laoId), message);
}

/**
 * Sends a query to open an election.
 *
 * @param laoId - The id of the lao in which the given election should be opened
 * @param election - The election that should be opened
 */
export function openElection(laoId: Hash, election: Election): Promise<void> {
  const time: Timestamp = Timestamp.EpochNow();
  const message = new OpenElection({
    lao: laoId,
    election: election.id,
    opened_at: time,
  });

  // publish on the LAO channel specific to this election
  return publish(channelFromIds(laoId, election.id), message);
}

/**
 * Sends a query to cast a vote during an election.
 *
 * @param laoId - The id of the lao in which this vote should be casted
 * @param election - The election for which the vote should be casted
 * @param selectedBallots - The votes to be added, a map from question index to the set of selected answer indices
 */
export function castVote(
  laoId: Hash,
  election: Election,
  selectedBallots: SelectedBallots,
): Promise<void> {
  const time: Timestamp = Timestamp.EpochNow();

  const message = new CastVote({
    lao: laoId,
    election: election.id,
    created_at: time,
    // Convert object to array
    votes: CastVote.selectedBallotsToVotes(election, selectedBallots),
  });

  // publish on the LAO channel specific to this election
  return publish(channelFromIds(laoId, election.id), message);
}

/**
 * Sends a query to terminate an election.
 *
 * @param laoId - The id of the lao in which the given election should be terminated
 * @param election - The election that should be terminated
 */
export function terminateElection(laoId: Hash, election: Election): Promise<void> {
  const time: Timestamp = Timestamp.EpochNow();
  const message = new EndElection({
    lao: laoId,
    election: election.id,
    created_at: time,
    registered_votes: EndElection.computeRegisteredVotesHash(election),
  });

  // publish on the LAO channel specific to this election
  return publish(channelFromIds(laoId, election.id), message);
}
